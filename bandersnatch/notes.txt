TESTS (overview)

Add:
	Addition commutative
	P + N = P
	P + (-P) = N
	Compatibility of Sub and Add
	Compatibility of Add and Double
	Associative Law

Aliasing

Consistency: 
	ConsistencyQueries: Consistency of IsNaP, IsAtInfinity, IsNeutralElement, IsE1, IsE2, XY(T)_affine wrt. conversion to reference Type

Coordinate consistency:
	reconstruction from XYZ_projective or XY_affine
	consistency of affine and projective coos
	consistency of extended coordinates

Endo:
	Endo maps to correct subgroup
	Endo acts correctly on 2-torsion
	Endo factors through P+A
	Endo nontrivial
	Endo(P+Q) = Endo(P) + Endo(Q)
	Endo(P) vs. \sqrt(2)*P  [full check depending on P mod subgroup]

Eq:
	AddEq, SubEq, DoubleEq, NegEq, EndoEq
Equality:
	Recognize neutrality (marked in samples)
	Recognize Equality (marked in samples)
Interface constraints:
	CanRepresentInfinity -> CurvePointPtrInterfaceDistinguishInfinity
	HasDecaf -> curvePointPtrInterfaceDecaf
	TODO! HasE1 etc.
Torsion:
	torsionAdder interface
Serialize:
	TODO!
Queries:
	Check consistency of sample flags with Validate, IsAtInfinity, NaP

/*
	Caveat: Bandersnatch is typically represented as a twisted Edwards curve, which means there are singularities
	at infinity. These singularities are not in the large-prime order subgroup. (the cofactor is 4)
	and only really correspond to curve points after desingularization anyway.

	To avoid these issues, we shall assert (and check on external input) that all points in the correct subgroup, which we
	represent as G' modulo P=P+A, where G' is the subgroup of rational point that is generated by the prime-order subgroup
	and the affine order-2 point A.
	Effectively, this means that we need to ensure that all points are in G' and that we work modulo A.

	The side effect of this is that avoid the singular cases for the addition law.

	Note that most non-comparison operations actually give the correct result even when not working modulo A.
	We explicitly document this if it is not the case (notably, when using the GLV endomorphism to speed up exponentiation)
	Unless explicitly specified otherwise, we do not guarantee correctness on our algorithms for points outside the subgroup G'.
*/


/// Old interface

/*
type CurvePointPtrInterfaceReadSerialize interface {
	// SerializeShort and SerializeLong serialize the given point in either short or long serialization format. err==nil iff everything worked OK.
	SerializeShort(output io.Writer) (bytes_written int, err error)
	SerializeLong(output io.Writer) (bytes_written int, err error)
}
*/

/*
type CurvePointPtrInterfaceRead interface {
	CurvePointPtrInterfaceCooRead

	// Checks whether the given curve point is the neutral element of the curve.
	IsNeutralElement() bool

	// IsEqual checks equality of points. Note that the library acts as if the points were converted to the same concrete type.
	IsEqual(CurvePointPtrInterfaceRead) bool

	// IsNaP checks whether the point is a NaP (Not-A-Point).
	// NaP's can only appear due to bugs in the library or due to screw-ups on the user's side such as using uninitialized variables or deserializing erroneous points as trusted inputs.
	// We mostly use this internally at certain places to protect/alert users when certain errors occur.
	// Note that singular cases for group operations also lead to NaPs (But these cases can only appear (outside of testing or working on the full curve) due to bugs in the library or the user screwing up)
	IsNaP() bool

	// AffineExtended() and ExtendedTwistedEdwards() create a copy of the given point in the appropriate coordinate type.
	AffineExtended() Point_axtw
	ExtendedTwistedEdwards() Point_xtw

	// Creates a copy of the point of the same type and returns it (Note that the returned value must have interface type and that interface contains a pointer)
	Clone() CurvePointPtrInterfaceRead

	// SerializeShort and SerializeLong serialize the given point in either short or long serialization format. err==nil iff everything worked OK.
	SerializeShort(output io.Writer) (bytes_written int, err error)
	SerializeLong(output io.Writer) (bytes_written int, err error)

	fmt.Stringer // i.e. Stringer() string  -- used to obtain a human-readable version of the point, used mostly for debugging.

	// This function is intended to return a constant true or false, depending on whether the
	// concrete type implementing the interface can correctly represent (and distinguish) the 2 points at infinity. -- Of course, these are not in the subgroup.
	// This is used in testing and should work even on a nil receiver of the given concrete curve point type.
	// If this returns true, CurvePointPtrInterfaceRead_FullCurve must be provided.
	CanRepresentInfinity() bool
}
*/

/*
// CurvePointPtrInterfaceRead_FullCurve is the "extended interface" that contains functions that are needed to operate outside the p253 - subgroup and the identification P=P+A.
// Question: We might *not* export this interface at all.
type CurvePointPtrInterfaceRead_FullCurve interface {
	CurvePointPtrInterfaceRead
	IsNeutralElement_FullCurve() bool
	IsEqual_FullCurve(CurvePointPtrInterfaceRead_FullCurve) bool
	IsAtInfinity() bool
}
*/

/*
type CurvePointPtrInterfaceWrite interface {
	// z.Add(x,y) computes z = x+y according to the elliptic curve group law.
	Add(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)

	// z.Sub(x,y) computes z = x-y according to the elliptic curve group law.
	Sub(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)

	// z.Double(x) computes z = x+x according to the elliptic curve group law.
	Double(CurvePointPtrInterfaceRead)

	// z.Neg(x) computes z = -x according to the elliptic curve group law.
	Neg(CurvePointPtrInterfaceRead)

	// z.Endo(x) compute z = \Psi(x) where \Psi is the non-trivial degree-2 endomorphism described in the bandersnatch paper.
	Endo(CurvePointPtrInterfaceRead)

	// z.SetNeutral() sets z to be the neutral element of the curve.
	SetNeutral()

	// z.AddEq(x) is equivalent to z.Add(z,x), i.e. z+=x
	AddEq(CurvePointPtrInterfaceRead)

	// z.SubEq(x) is equivalent to z.Sub(z,x), i.e. z-=xx
	SubEq(CurvePointPtrInterfaceRead)

	// z.DoubleEq() is equivalent to z.Double(z), i.e. z*=2
	DoubleEq()

	// z.NegEq() is equivalent to z.Neg(z), i.e. z*=(-1)
	NegEq()

	// z.EndoEq() is equivalent to z.Endo(z)
	EndoEq()

	// z.SetFrom(x) sets z to x (with appropriate type conversion)
	SetFrom(CurvePointPtrInterfaceRead)

	// DeserialzeShort deserialize from the given input byte stream (expecting it to start with a point in short serialization format) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeShort(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)

	// DeserialzeLong deserialize from the given input byte stream (expecting it to start with a point in long serialization format) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeLong(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)

	// DeserialzeAuto deserialize from the given input byte stream (expecting it to start with a point in either short or long serialization format -- it autodetects that) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeAuto(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)
}
*/

// Note: We also have MapToFieldElement(CurvePointRead) FieldElement as a free-function that acts as an injective map p253 -> BaseField

// Note: Some of these are unused. Make consistent with Bandersnatch paper.
