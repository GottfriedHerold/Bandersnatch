package bandersnatch

import (
	"math/big"
	"math/rand"
)

// point_xtw_base is a struct holding x,y,t,z values that can be used to represent an elliptic curve point on the Bandersnatch curve.
// Note that this is just a container for coordinates. It (or pointers to it) does not satisfy the CurvePointPtrInterface.
// Indeed, there is the question how to interpret x,y,t,z coordinates as coos of a point and depending on context, we
// either work modulo A or not.
// We use struct embedding to create Point_xtw_subgroup and Point_xtw_full from it.
type point_xtw_base struct {
	thisCurvePointCanRepresentFullCurve
	thisCurvePointCanRepresentInfinity
	x FieldElement
	y FieldElement
	z FieldElement
	t FieldElement
}

// Point_xtw describes points on the p253-subgroup of the Bandersnatch curve in extended twisted Edwards coordinates.
// Extended means that we additionally store T with T = X*Y/Z. Note that both Y and Z are never 0 for points in the subgroup.
// cf. https://iacr.org/archive/asiacrypt2008/53500329/53500329.pdf
type Point_xtw_subgroup struct {
	thisCurvePointCanOnlyRepresentSubgroup
	thisCurvePointCannotRepresentInfinity
	point_xtw_base
}

// Point_xtw_full describes rational points on the Bandersnatch elliptic curve in extended twisted Edwards coordinates.
// Extended means that we additionally store T with T*Z = X*Y.
// This curve point type can store rational points outside of the p253 prime-order subgroup and points at infinity.
// Note that, being a twisted Edwards curve, the neutral element is NOT at infinity.
//
// NOTE: There are actually two (distinct) points at infinity. Apart from actually being more efficient, the extra T coordinate is needed
// to distinguish those two; notably, the usual (projective) twisted Edwards form ax^2 + y^2 = z^2 + dt^2
// has singularities at infinity (in the form of self-intersections).
// Due to a/d being a square, we actually have *rational* points at infinity and we need to care about this.
// The extra t coordinate acts as a desingularization.
type Point_xtw_full struct {
	point_xtw_base
}

type CurvePointSlice_xtw_subgroup []Point_xtw_subgroup
type CurvePointSlice_xtw_full []Point_xtw_full

func (v CurvePointSlice_xtw_subgroup) GetByIndex(n int) CurvePointPtrInterface {
	return &v[n]
}

func (v CurvePointSlice_xtw_full) GetByIndex(n int) CurvePointPtrInterface {
	return &v[n]
}

/*
	NOTE: Points described by Point_xtw_<foo> should really been seen as solutions to the set of homogeneous equations

	ax^2 + y^2 = z^2 + dt^2
	x*y = z*t

	with addition law for P3 = P1 + P2 given by:
	X3 = (X1Y2 + Y1X2)(Z1Z2 - dT1T2)
	Y3 = (Y1Y2 - aX1X2)(Z1Z2 + dT1T2)
	T3 = (X1Y2 + Y1X2)(Y1Y2-aX1X2)
	Z3 = (Z1Z2 - dT1T2)(Z1Z2 + dT1T2)

	which we call the extended twisted Edwards model. We treat this as a curve model (like Weierstrass, Montgomery, (twisted) Edwards) rather than a redundant coordinate representaion.

	Clearly, the set of affine solutions corresponds exactly to the set of affine solutions of the usual twisted Edwards equation ax^2 + y^2 = 1+dx^2y^2
	(with z==1, t==x*y), but there are differences in the behaviour at infinity:
	Notably, the twisted Edwards curve has 2+2 points at infinity and the curve is actually singular there:
	Those are double (in the sense that a desingularization results in two points) points at (1:0:0), (0:1:0) each.
	By contrast, the extended twisted Edwards model has no singularities for a != +/-d (over the algebraic closure, to be clear).
	In fact, the additional t coordinate both improves efficiency and is a very convenient desingularization, where things become more clear.
	The (not neccessarily rational) points at infinity (z==0) of this model are in (x:y:t:z) coordinates:
	(0:sqrtz(d):1:0), (0:-sqrt(d):1:0), (sqrt(d/a):0:1:0), (-sqrt(d/a):0:1:0)
	The first two point have order 4 (doubling them gives (0:-1:0:1)), the latter two points have order 2.
	Now, in the case usually considered in the literature, d is a non-square and a is a square.
	Then all these points at infinity are actually not rational and we even get a unified point addition law that works for all rational points.

	In the bandersnatch case, both a and d are non-squares. This means we get two bona-fide rational(!) points at infinity of order 2.
	The addition law above no longer works in all cases. A lengthy analysis (TODO: Make a pdf and write up the proof or find one in literature) shows that the following holds

	Theorem:
	for P1,P2 rational, the extended Edwards addition law given above for P1 + P2 does not work if and only if P1 - P2 is a point at infinity.

	Consequences:
	The addition law works for all points in the subgroup of size 2*p253, generated by the large-prime p253 subgroup and the affine point A of order 2.
	If P1,P2 are both contained in a cyclic subgroup generated by Q, then the addition law can only fail in the following cases:
		One of P1,P2 is the neutral element, the other one is equal to Q and is a point at infinity.
		Q has order 2*p253, P1 = alpha * Q, P2 = beta * Q with alpha-beta == p253 mod 2*p253. We can actually ensure that never happens in our exponentiation algorithms.

	Our Point_xtw_subgroup implementation operates by representing a point P by either coos of P or P+A (and works modulo A).
	Due to the above comment, this means that the standard addition law for Point_xtw_subgroup is complete.
*/

// TODO: Define and export in other coo formats?

// example point on the subgroup specified in the bandersnatch paper
var example_generator_x *big.Int = initIntFromString("0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18")
var example_generator_y *big.Int = initIntFromString("0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166")
var example_generator_t *big.Int = new(big.Int).Mul(example_generator_x, example_generator_y)
var example_generator_xtw point_xtw_base = func() (ret point_xtw_base) {
	ret.x.SetBigInt(example_generator_x)
	ret.y.SetBigInt(example_generator_y)
	ret.t.SetBigInt(example_generator_t)
	ret.z.SetOne()
	return
}()

// SubgroupGenerator_xtw_subgroup denotes the example generator (with type Point_xtw_subgroup) of the p253 prime-order subgroup of the Bandersnatch curve that was
// mentioned in the Bandersnatch paper. Its x coordinate is 0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18.
var SubgroupGenerator_xtw_subgroup Point_xtw_subgroup = Point_xtw_subgroup{point_xtw_base: example_generator_xtw}

/*
	Basic functions for Point_xtw
*/

// neutralElement_xtwbase denotes the neutral element of the Bandersnatch curve in projective extended twisted Edwards coordinates.
var (
	neutralElement_xtwbase point_xtw_base = point_xtw_base{x: FieldElementZero, y: FieldElementOne, t: FieldElementZero, z: FieldElementOne}
)

// NeutralElement_xtw_subgroup resp. full denotes the neutral element of the Bandersnatch curve (with type Point_xtw_subgroup resp. Point_xtw_full).
var (
	NeutralElement_xtw_subgroup Point_xtw_subgroup = Point_xtw_subgroup{point_xtw_base: neutralElement_xtwbase}
	NeutralElement_xtw_full     Point_xtw_full     = Point_xtw_full{point_xtw_base: neutralElement_xtwbase}
)

// These are the three points of order 2 that we can represent with extended twisted coordinates. None of these is in the p253-subgroup, of course.
// Although we do not need or use this, note that SqrtDDivA_fe := sqrt(d/a) == sqrt(2) - 1 due to the way the bandersnatch curve was constructed.
var (
	orderTwoPoint_xtw point_xtw_base = point_xtw_base{x: FieldElementZero, y: FieldElementMinusOne, t: FieldElementZero, z: FieldElementOne}
)

// AffineOrderTwoPoint_xtw denotes the affine point of order two of the Bandersnatch curve (with type Point_xtw_full). This point is not on the p253 prime order subgroup.
var AffineOrderTwoPoint_xtw Point_xtw_full = Point_xtw_full{point_xtw_base: orderTwoPoint_xtw}

// infinitePoint1_xtw and infinitePoint2_xtw denote the the infinite points E1 and E2 of order two on the Bandersnatch curve (of type Point_efgh_full).
// These points are not on the p253 prime order subgroup.
// The distinction between these two points is essentially arbitrary, but done in a way consistent with IsE1() and IsE2() and conversion to other point types.
var (
	infinitePoint1_xtw_base point_xtw_base = point_xtw_base{x: squareRootDbyA_fe, y: FieldElementZero, t: FieldElementOne, z: FieldElementZero}
	infinitePoint2_xtw_base point_xtw_base = point_xtw_base{x: squareRootDbyA_fe, y: FieldElementZero, t: FieldElementMinusOne, z: FieldElementZero}
	InfinitePoint1_xtw      Point_xtw_full = Point_xtw_full{point_xtw_base: infinitePoint1_xtw_base}
	InfinitePoint2_xtw      Point_xtw_full = Point_xtw_full{point_xtw_base: infinitePoint2_xtw_base}
)

// normalizeAffineZ replaces the internal representation with an equivalent one with Z==1, unless the point is at infinity (in which case we panic).
// This is used to convert to or output affine coordinates.
func (p *point_xtw_base) normalizeAffineZ() {
	if p.IsNaP() {
		napEncountered("Try to converting invalid point xtw to coos with z==1", false, p)
		// If the above did not panic, we replace the NaP p by a default NaP with x==y==t==0, z==1.
		// This ensures that conversion from NaPs to other point types result in NaPs.
		*p = point_xtw_base{z: FieldElementOne} // invalid point
		return
	}

	// We reasonably likely call normalizeAffineZ several times in a row on the same point. If Z==1 to start with, do nothing.
	if p.z.IsOne() {
		return
	}
	if p.z.IsZero() {
		// division by zero error
		panic("Trying to make point at infinity affine")
	}
	var zInverse FieldElement
	zInverse.Inv(&p.z)
	p.x.MulEq(&zInverse)
	p.y.MulEq(&zInverse)
	p.t.MulEq(&zInverse)
	p.z.SetOne()
}

// normalizeSubgroup changes the internal representation of p, such that the coordinates of p
// corresponds exactly to p (without working modulo the affine two-torsion point).
func (p *Point_xtw_subgroup) normalizeSubgroup() {
	if !legendreCheckE1_projectiveYZ(p.y, p.z) {
		p.flipDecaf()
	}
}

// flipDecaf changes the internal representation of P from P to P+A or vice versa (note that we work modulo A).
// flipDecaf is needed to satisfy the (optional) curvePointPtrInterfaceDecaf interface that is recognized by the testing framework.
func (p *Point_xtw_subgroup) flipDecaf() {
	p.x.NegEq()
	p.y.NegEq()
}

// TODO: Might go away

// HasDecaf needs to return true for flipDecaf to be recognized by the testing framework.
func (p *Point_xtw_subgroup) HasDecaf() bool {
	return true
}

// rerandomizeRepresentation is needed to satisfy the CurvePointPtrInterfaceTestSample interface for testing. It changes the internal representation to an equivalent one.
func (p *point_xtw_base) rerandomizeRepresentation(rnd *rand.Rand) {
	var m FieldElement
	m.setRandomUnsafeNonZero(rnd)
	p.x.MulEq(&m)
	p.y.MulEq(&m)
	p.t.MulEq(&m)
	p.z.MulEq(&m)
}

// rerandomizeRepresentation is needed to satisfy the CurvePointPtrInterfaceTestSample interface for testing. It changes the internal representation to an equivalent one.
func (p *Point_xtw_subgroup) rerandomizeRepresentation(rnd *rand.Rand) {
	p.point_xtw_base.rerandomizeRepresentation(rnd)
	if rnd.Intn(2) == 0 {
		p.flipDecaf()
	}
}

// X_affine returns the X coordinate of the given point in affine twisted Edwards coordinates, i.e. X/Z.
func (p *Point_xtw_subgroup) X_affine() FieldElement {
	p.normalizeAffineZ()
	p.normalizeSubgroup()
	return p.x
}

// X_affine returns the X coordinate of the given point in affine twisted Edwards coordinates, i.e. X/Z.
func (p *Point_xtw_full) X_affine() FieldElement {
	p.normalizeAffineZ()
	return p.x
}

// Y_affine returns the Y coordinate of the given point in affine twisted Edwards coordinates, i.e. Y/Z.
func (p *Point_xtw_subgroup) Y_affine() FieldElement {
	p.normalizeAffineZ()
	p.normalizeSubgroup()
	return p.y
}

// Y_affine returns the Y coordinate of the given point in affine twisted Edwards coordinates, i.e. Y/Z.
func (p *Point_xtw_full) Y_affine() FieldElement {
	p.normalizeAffineZ()
	return p.y
}

// T_affine returns the T coordinate of the given point in affine twisted Edwards coordinates, i.e. X/Z * Y/Z.
func (p *Point_xtw_subgroup) T_affine() FieldElement {
	p.normalizeAffineZ()
	p.normalizeSubgroup()
	return p.t
}

// T_affine returns the T coordinate of the given point in affine twisted Edwards coordinates, i.e. X/Z * Y/Z.
func (p *Point_xtw_full) T_affine() FieldElement {
	p.normalizeAffineZ()
	return p.t
}

// XY_affine returns the X and Y coordinate of the given point in affine twisted Edwards coordinates. It is equivalent to calling X_affine and Y_affine, but may be more efficient.
func (p *Point_xtw_subgroup) XY_affine() (FieldElement, FieldElement) {
	p.normalizeAffineZ()
	p.normalizeSubgroup()
	return p.x, p.y
}

// XY_affine returns the X and Y coordinate of the given point in affine twisted Edwards coordinates. It is equivalent to calling X_affine and Y_affine, but may be more efficient.
func (p *Point_xtw_full) XY_affine() (FieldElement, FieldElement) {
	p.normalizeAffineZ()
	return p.x, p.y
}

// XYT_affine returns the X, Y and T=X*Y coordinate of the given point in affine twisted Edwards coordinates. It is equivalent to calling X_affine, Y_affine and T_affine, but may be more efficient.
func (p *Point_xtw_subgroup) XYT_affine() (FieldElement, FieldElement, FieldElement) {
	p.normalizeAffineZ()
	p.normalizeSubgroup()
	return p.x, p.y, p.t
}

// XYT_affine returns the X, Y and T=X*Y coordinate of the given point in affine twisted Edwards coordinates. It is equivalent to calling X_affine, Y_affine and T_affine, but may be more efficient.
func (p *Point_xtw_full) XYT_affine() (FieldElement, FieldElement, FieldElement) {
	p.normalizeAffineZ()
	return p.x, p.y, p.t
}

// X_projective returns the X coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_subgroup) X_projective() FieldElement {
	p.normalizeSubgroup()
	return p.x
}

// X_projective returns the X coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_full) X_projective() FieldElement {
	return p.x
}

// Y_projective returns the Y coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_subgroup) Y_projective() FieldElement {
	p.normalizeSubgroup()
	return p.y
}

// Y_projective returns the Y coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_full) Y_projective() FieldElement {
	return p.y
}

// Z_projective returns the Z coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_subgroup) Z_projective() FieldElement {
	p.normalizeSubgroup()
	return p.z
}

// Z_projective returns the Z coordinate of the given point in projective twisted Edwards coordinates.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_full) Z_projective() FieldElement {
	return p.z
}

// XYZ_projective returns X,Y and Z coordinates in projective twisted Edwards coordinates in a single call.
// It is equivalent to calling X_projective(), Y_projective(), Z_projective(), but may be more efficient.
func (p *Point_xtw_subgroup) XYZ_projective() (FieldElement, FieldElement, FieldElement) {
	p.normalizeSubgroup()
	return p.x, p.y, p.z
}

// XYZ_projective returns X,Y and Z coordinates in projective twisted Edwards coordinates in a single call.
// It is equivalent to calling X_projective(), Y_projective(), Z_projective(), but may be more efficient.
func (p *Point_xtw_full) XYZ_projective() (FieldElement, FieldElement, FieldElement) {
	return p.x, p.y, p.z
}

// T_projective returns the T coordinate of the given point in projective twisted Edwards coordinates. This coordinate satisfies X*Y = T*Z.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_subgroup) T_projective() FieldElement {
	p.normalizeSubgroup()
	return p.t
}

// T_projective returns the T coordinate of the given point in projective twisted Edwards coordinates. This coordinate satisfies X*Y = T*Z.
//
// CAVEAT: Subsequent calls to any <foo>_projective methods on the same point are only guaranteed to be consistent if nothing else is done with the point between the calls.
// This includes that you may not be able to use the point as argument to even seemingly read-only methods, as these might touch the redundant internal representation.
func (p *Point_xtw_full) T_projective() FieldElement {
	return p.t
}

// XYTZ_projective returns X,Y,T and Z coordinates in projective twisted Edwards coordinates in a single call.
// It is equivalent to calling X_projective(), Y_projective(), T_projective(), Z_projective(), but may be more efficient.
func (p *Point_xtw_subgroup) XYTZ_projective() (FieldElement, FieldElement, FieldElement, FieldElement) {
	p.normalizeSubgroup()
	return p.x, p.y, p.t, p.z
}

// XYTZ_projective returns X,Y,T and Z coordinates in projective twisted Edwards coordinates in a single call.
// It is equivalent to calling X_projective(), Y_projective(), T_projective(), Z_projective(), but may be more efficient.
func (p *Point_xtw_full) XYTZ_projective() (FieldElement, FieldElement, FieldElement, FieldElement) {
	return p.x, p.y, p.t, p.z
}

// X_decaf_projective returns the X coordinate of either P or P+A in projective twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_projective methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_projective methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_affine methods.
//
// Note: If P has extended projective Edwards coordinates X:Y:T:Z, then P+A has coordinates -X:-Y:T:Z == X:Y:-T:-Z
func (p *point_xtw_base) X_decaf_projective() FieldElement {
	return p.x
}

// Y_decaf_projective returns the Y coordinate of either P or P+A in projective twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_projective methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_projective methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_affine methods.
//
// Note: If P has extended projective Edwards coordinates X:Y:T:Z, then P+A has coordinates -X:-Y:T:Z == X:Y:-T:-Z
func (p *point_xtw_base) Y_decaf_projective() FieldElement {
	return p.y
}

// T_decaf_projective returns the T coordinate of either P or P+A in projective twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_projective methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_projective methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_affine methods.
//
// Note: If P has extended projective Edwards coordinates X:Y:T:Z, then P+A has coordinates -X:-Y:T:Z == X:Y:-T:-Z
func (p *point_xtw_base) T_decaf_projective() FieldElement {
	return p.t
}

// Z_decaf_projective returns the Z coordinate of either P or P+A in projective twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_projective methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_projective methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_affine methods.
//
// Note: If P has extended projective Edwards coordinates X:Y:T:Z, then P+A has coordinates -X:-Y:T:Z == X:Y:-T:-Z
func (p *point_xtw_base) Z_decaf_projective() FieldElement {
	return p.z
}

// X_decaf_affine returns the X coordinate of either P or P+A in affine twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_affine methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_affine methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_projective methods.
//
// Note: If P has extended projective Edwards coordinates (with Z==1) X:Y:T:1, then P+A has coordinates -X:-Y:T:1.
func (p *point_xtw_base) X_decaf_affine() FieldElement {
	p.normalizeAffineZ()
	return p.x
}

// Y_decaf_affine returns the Y coordinate of either P or P+A in affine twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_affine methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_affine methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_projective methods.
//
// Note: If P has extended projective Edwards coordinates (with Z==1) X:Y:T:1, then P+A has coordinates -X:-Y:T:1.
func (p *point_xtw_base) Y_decaf_affine() FieldElement {
	p.normalizeAffineZ()
	return p.y
}

// T_decaf_affine returns the T coordinate of either P or P+A in affine twisted Edwards coordinates, where A is the affine point of order two.
//
// CAVEAT: Subsequent calls to any <foo>_decaf_affine methods are only guaranteed to be consistent if nothing else is done with the point between those calls.
// The consistency guarantee includes that different <foo>_decaf_affine methods make the same P vs. P+A choice.
// The requirements include not using the point as (pointer) argument to seemingly read-only methods (as these might change the internal representation) and not using <foo>_decaf_projective methods.
//
// Note: If P has extended projective Edwards coordinates (with Z==1) X:Y:T:1, then P+A has coordinates -X:-Y:T:1.
// In particular, T_decaf_affine and T_affine match (except for the requirements on not interleaving method calls).
func (p *point_xtw_base) T_decaf_affine() FieldElement {
	p.normalizeAffineZ()
	return p.t
}

// IsInSubgroup checks whether the given curve point is in the p253 prime-order subgroup.
func (p *Point_xtw_full) IsInSubgroup() bool {
	if p.IsNaP() {
		return napEncountered("Checking whether NaP is in subgroup", true, p)
	}
	return legendreCheckA_projectiveXZ(p.x, p.z) && legendreCheckE1_projectiveYZ(p.y, p.z)
}

// TODO
/*
// SerializeLong serialize the given point in long serialization format. err==nil iff everything worked OK.
func (p *Point_xtw) SerializeLong(output io.Writer) (bytes_written int, err error) {
	return default_SerializeLong(p, output)
}

// SerializeShort serialize the given point in short serialization format. err==nil iff everything worked OK.
func (p *Point_xtw) SerializeShort(output io.Writer) (bytes_written int, err error) {
	return default_SerializeShort(p, output)
}
*/

// TODO !

/*
// DeserializeShort deserialize from the given input byte stream (expecting it to start with a point in short serialization format) and store the result in the receiver.
// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
// Note that long format is considerably more efficient to deserialize.
func (p *Point_xtw) DeserializeShort(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error) {
	return default_DeserializeShort(p, input, trusted)
}

// DeserializeLong deserialize from the given input byte stream (expecting it to start with a point in long serialization format) and store the result in the receiver.
// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
// Note that long format is considerably more efficient to deserialize.
func (p *Point_xtw) DeserializeLong(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error) {
	return default_DeserializeLong(p, input, trusted)
}

// DeserializeAuto deserialize from the given input byte stream (expecting it to start with a point in either short or long serialization format -- it autodetects that) and store the result in the receiver.
// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
// Note that long format is considerably more efficient to deserialize.
func (p *Point_xtw) DeserializeAuto(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error) {
	return default_DeserializeAuto(p, input, trusted)
}

*/

// String is defined to satisfy the fmt.Stringer interface and allows points to be used in most fmt routines.
// Note that String() is defined on value receivers (as opposed to everything else) for an easier interface when using fmt routines.
//
// NOTE: Output format of String is not stable yet.
func (p point_xtw_base) String() string {
	// Not the most efficient way to concatenate strings, but good enough.
	return p.x.String() + ":" + p.y.String() + ":" + p.t.String() + ":" + p.z.String()
}

// String is defined to satisfy the fmt.Stringer interface and allows points to be used in most fmt routines.
// Note that String() is defined on value receivers (as opposed to everything else) for an easier interface when using fmt routines.
//
// NOTE: Output format of String is not stable yet.
func (p Point_xtw_subgroup) String() (ret string) {
	ret = p.point_xtw_base.String()
	if !legendreCheckE1_projectiveYZ(p.y, p.z) {
		ret += " [+A]"
	}
	return
}

/*
// AffineExtended returns a copy of the point in affine extended coordinates.
func (p *Point_xtw) AffineExtended() Point_axtw {
	panic("Needs to change")
	p.normalizeAffineZ()
	return Point_axtw{x: p.x, y: p.y, t: p.t}
}
*/

/*
func (p *point_xtw_base) toDecaf_xtw() point_xtw_base {
	return *p
}

func (p *point_xtw_base) toDecaf_axtw() point_axtw_base {
	p.normalizeAffineZ()
	return point_axtw_base{x: p.x, y: p.y, t: p.t}
}
*/

// Clone returns a pointer to an independent copy of the given base point struct.
// The returned pointer is returned in a CurvePointPtrInterfaceBaseRead interface, but the actual value is guaranteed to have the same type as the receiver.
func (p *point_xtw_base) Clone() CurvePointPtrInterfaceBaseRead {
	p_copy := *p
	return &p_copy
}

// Clone returns a pointer to an independent copy of the given point.
// The returned pointer is returned in a CurvePointPtrInterface interface, but the actual value is guaranteed to have the same type as the receiver.
func (p *Point_xtw_full) Clone() CurvePointPtrInterface {
	p_copy := *p
	return &p_copy
}

// Clone returns a pointer to an independent copy of the given point.
// The returned pointer is returned in a CurvePointPtrInterface interface, but the actual value is guaranteed to have the same type as the receiver.
func (p *Point_xtw_subgroup) Clone() CurvePointPtrInterface {
	p_copy := *p
	return &p_copy
}

// IsNeutralElement checks if the given point p is the neutral element of the curve.
func (p *Point_xtw_subgroup) IsNeutralElement() bool {
	// The only point with x==0 are the neutral element N and the affine order-two point A, which we work modulo.
	if p.x.IsZero() {
		if p.y.IsZero() {
			return napEncountered("compared invalid xtw point to zero", true, p)
		}
		return true
	}
	if p.t.IsZero() {
		panic("Non-NaP xtw with x!=0, t==0")
	}
	return false
}

// IsNeutralElement checks if the given point p is the neutral element of the curve.
func (p *Point_xtw_full) IsNeutralElement() bool {
	if !p.x.IsZero() {
		return false
	}
	if p.IsNaP() {
		return napEncountered("compared invalid xtw point to zero exactly", true, p)
	}
	if !p.t.IsZero() {
		panic("Non-NaP xtw point with x==0, but t!=0 encountered.")
	}
	// we know x==0, y!=0 (because otherwise, we have a NaP), t==0.
	// This implies z == +/- y
	return p.y.IsEqual(&p.z)
}

// SetNeutral sets the given point to the neutral element of the curve.
func (p *point_xtw_base) SetNeutral() {
	*p = neutralElement_xtwbase
}

// IsNaP checks whether the point is a NaP (Not-a-point). NaPs must never appear if the library is used correctly. They can appear by
// a) zero-initialized points are NaPs (Go lacks constructors to fix that).
// b) performing operations on NaPs.
// c) bugs (either in the library or as a corner case due to wrong usage of doing untrusted conversion to subgroup of points outside the subgroup)
//
// For Point_xtw's, NaPs have x==y==0.
// The reason why we check x==y==0 and do not check t,z is due to what happens if we perform mixed additions with other point types.
func (p *point_xtw_base) IsNaP() bool {
	return p.x.IsZero() && p.y.IsZero()
}

// Add performs curve point addition according to the elliptic curve group law.
// Use p.Add(&x, &y) for p = x + y.
func (p *Point_xtw_subgroup) Add(x CurvePointPtrInterfaceRead, y CurvePointPtrInterfaceRead) {
	// TODO: Optimize. For certain edge cases, going directly to xtw is slightly more efficient.
	var result Point_efgh_subgroup
	result.Add(x, y)
	p.SetFrom(&result)

	// Old implementation from before to subgroup vs. full split
	/*
		switch x := x.(type) {
		case *Point_xtw:
			switch y := y.(type) {
			case *Point_xtw:
				p.add_ttt(x, y)
			case *Point_axtw:
				p.add_tta(x, y)
			default:
				var y_converted Point_xtw = convertToPoint_xtw(y)
				p.add_ttt(x, &y_converted)
			}
		case *Point_axtw:
			switch y := y.(type) {
			case *Point_xtw:
				p.add_tta(y, x)
			case *Point_axtw:
				p.add_taa(x, y)
			default:
				var y_converted Point_xtw = convertToPoint_xtw(y)
				p.add_tta(&y_converted, x)

			}
		default: // for x
			var x_converted Point_xtw = convertToPoint_xtw(x)

			switch y := y.(type) {
			case *Point_xtw:
				p.add_ttt(&x_converted, y)
			case *Point_axtw:
				p.add_tta(&x_converted, y)
			default:
				var y_converted Point_xtw = convertToPoint_xtw(y)
				p.add_ttt(&x_converted, &y_converted)
			}
		}
	*/
}

// Add performs curve point addition according to the elliptic curve group law.
// Use p.Add(&x, &y) for p = x + y.
func (p *Point_xtw_full) Add(x, y CurvePointPtrInterfaceRead) {
	var result_efgh Point_efgh_full
	result_efgh.Add(x, y)
	p.SetFrom(&result_efgh)
}

// Sub performs curve point subtraction according to the elliptic curve group law.
// Use p.Sub(&x, &y) for p = x - y.
func (p *Point_xtw_subgroup) Sub(x, y CurvePointPtrInterfaceRead) {
	var result_efgh Point_efgh_subgroup
	result_efgh.Sub(x, y)
	p.SetFrom(&result_efgh)
}

// Sub performs curve point subtraction according to the elliptic curve group law.
// Use p.Sub(&x, &y) for p = x - y.
func (p *Point_xtw_full) Sub(x, y CurvePointPtrInterfaceRead) {
	var result_efgh Point_efgh_full
	result_efgh.Sub(x, y)
	p.SetFrom(&result_efgh)
}

// Double computes the sum of a point with itself.
// p.Double(&x) means p = x + x.
//
// Note that x + x is always in the prime-order subgroup.
// As opposed to p.Add(&x, &x), p.Double(&x) works even if the type of p can only hold subgroup curve points and the type of x can hold general points.
func (p *point_xtw_base) Double(input CurvePointPtrInterfaceRead) {
	var result_efgh point_efgh_base
	result_efgh.Double(input)
	*p = result_efgh.toDecaf_xtw()
}

// Neg computes the negative of the point wrt the elliptic curve group law.
// Use p.Neg(&input) for p = -input.
func (p *Point_xtw_subgroup) Neg(input CurvePointPtrInterfaceRead) {
	p.SetFrom(input)
	p.NegEq()
}

// Neg computes the negative of the point wrt the elliptic curve group law.
// Use p.Neg(&input) for p = -input.
func (p *Point_xtw_full) Neg(input CurvePointPtrInterfaceRead) {
	p.SetFrom(input)
	p.NegEq()
}

// Endo computes the efficient order-2 endomorphism on the given point described in the Bandersnatch paper.
//
// On the prime-order subgroup, this endomorphism acts as multiplication by the constant given as EndomorphismEivenvalue, which is
// a square root of -2.
func (p *Point_xtw_subgroup) Endo(input CurvePointPtrInterfaceRead) {
	var result_efgh Point_efgh_subgroup
	result_efgh.Endo(input)
	p.SetFrom(&result_efgh)
}

// Endo computes the efficient order-2 endomorphism on the given point described in the Bandersnatch paper.
//
// On the prime-order subgroup, this endomorphism acts as multiplication by the constant given as EndomorphismEivenvalue, which is
// a square root of -2.
func (p *Point_xtw_full) Endo(input CurvePointPtrInterfaceRead) {
	var result_efgh Point_efgh_full
	result_efgh.Endo(input)
	p.SetFrom(&result_efgh)
}

// IsAtInfinity tests whether the point is an infinite (neccessarily order-2) point.
//
// Note that for the Bandersnatch curve in twisted Edwards coordinates, there are two rational points at infinity; these points are not in the p253-subgroup and differ from the neutral element.
func (p *point_xtw_base) IsAtInfinity() bool {
	if p.IsNaP() {
		return napEncountered("checking whether NaP point is at infinity", false, p)
	}
	if p.z.IsZero() {
		// The only valid points (albeit not in subgroup) with z == 0 are the two exceptional points with z==y==0
		// We catch x==y==0 above (which already means the user of the library screwed up).

		// None of these can ever happen unless the library author messed up.
		if !p.y.IsZero() {
			panic("xtw point with z==0, but y!=0 encountered.")
		}
		// TODO: Remove?
		if p.t.IsZero() {
			panic("xtw point with z==t==0 encountered, but (x,y) != (0,0), so this was not NaP. This must never happen.")
		}
		// impossible, because y==0 and no NaP
		if p.x.IsZero() {
			panic("Non-NaP xtw point with z==0 and, y==0 and x==0 encountered. This is impossible")
		}
		return true
	}
	return false
}

// IsAtInfinity tests whether the point is an infinite (neccessarily order-2) point.
//
// Note that for the Bandersnatch curve in twisted Edwards coordinates, there are two rational points at infinity; these points are not in the p253-subgroup and differ from the neutral element.
// Consequently, this cannot return true for Points of type Point_xtw_subgroup.
func (p *Point_xtw_subgroup) IsAtInfinity() bool {
	if p.IsNaP() {
		return napEncountered("checking whether NaP point is at infinity", false, p)
	}
	return false
}

// IsE1 checks if the given point is the E1 point at infinity of the curve.
//
// Note that none of the points at infinity is in the p253 prime-order subgroup and so the method cannot return true for Point_xtw_subgroup.
// Also note that for twisted Edwards curves, the neutral element is NOT at infinity.
func (p *point_xtw_base) IsE1() bool {
	if !p.IsAtInfinity() {
		return false
	}
	var tmp FieldElement
	tmp.Mul(&p.t, &squareRootDbyA_fe)
	return tmp.IsEqual(&p.x)
}

// IsE2 checks if the given point is the E2 point at infinity of the curve.
//
// Note that none of the points at infinity is in the p253 prime-order subgroup and so the method cannot return true for Point_xtw_subgroup.
// Also note that for twisted Edwards curves, the neutral element is NOT at infinity.
func (p *point_xtw_base) IsE2() bool {
	if !p.IsAtInfinity() {
		return false
	}
	var tmp FieldElement
	tmp.Mul(&p.t, &squareRootDbyA_fe)
	tmp.NegEq()
	return tmp.IsEqual(&p.x)
}

// IsEqual compares two curve points for equality.
// The two points do not have to be in the same coordinate format.
func (p *Point_xtw_subgroup) IsEqual(other CurvePointPtrInterfaceRead) bool {
	switch other := other.(type) {
	case *Point_xtw_subgroup:
		ret, potentialNaP := p.isEqual_moduloA_tt(&other.point_xtw_base)
		if potentialNaP && (p.IsNaP() || other.IsNaP()) {
			return napEncountered("NaP detected during comparison of xtw points", true, p, other)
		}
		return ret
	case *Point_xtw_full:
		p.normalizeSubgroup()
		ret, potentialNaP := p.isEqual_exact_tt(&other.point_xtw_base)
		if potentialNaP && (p.IsNaP() || other.IsNaP()) {
			return napEncountered("NaP detected during comparison of xtw_subgroup and xtw points", true, p, other)
		}
		return ret
	case *Point_axtw_subgroup:
		ret, potentialNaP := p.isEqual_moduloA_ta(&other.point_axtw_base)
		if potentialNaP && (p.IsNaP() || other.IsNaP()) {
			return napEncountered("NaP detected during comparison of xtw_subgroup and axtw_subgroup points", true, p, other)
		}
		return ret
	case *Point_axtw_full:
		p.normalizeSubgroup()
		if p.IsNaP() || other.IsNaP() {
			return napEncountered("NaP detected during comparison of xtw_subgroup and axtw_full points", true, p, other)
		}
		return p.isEqual_exact_ta(&other.point_axtw_base)
	default:
		if p.IsNaP() || other.IsNaP() {
			return napEncountered("NaP detected during comparison of xtw_subgroup and other point", true, p, other)
		}
		if other.CanOnlyRepresentSubgroup() {
			ret, _ := p.isEqual_moduloA_tany(other)
			return ret
		} else {
			p.normalizeSubgroup()
			return p.isEqual_exact_tany(other)
		}
	}
}

// IsEqual compares two curve points for equality.
// The two points do not have to be in the same coordinate format.
func (p *Point_xtw_full) IsEqual(other CurvePointPtrInterfaceRead) bool {
	if p.IsNaP() || other.IsNaP() {
		return napEncountered("NaP detected during comparison of xtw_full and other point", true, p, other)
	}
	switch other := other.(type) {
	case *Point_xtw_full:
		ret, _ := p.isEqual_exact_tt(&other.point_xtw_base)
		return ret
	case *Point_xtw_subgroup:
		other.normalizeSubgroup()
		ret, _ := p.isEqual_exact_tt(&other.point_xtw_base)
		return ret
	case *Point_axtw_full:
		return p.isEqual_exact_ta(&other.point_axtw_base)
	case *Point_axtw_subgroup:
		other.normalizeSubgroup()
		return p.isEqual_exact_ta(&other.point_axtw_base)
	default:
		return p.isEqual_exact_tany(other)
	}
}

// EndoEq applies the endomorphism on the given point p, overwriting it.
//
// p.EndoEq() is equivalent to p.Endo(&p).
func (p *Point_xtw_subgroup) EndoEq() {
	p.Endo(p)
}

// EndoEq applies the endomorphism on the given point p, overwriting it.
//
// p.EndoEq() is equivalent to p.Endo(&p).
func (p *Point_xtw_full) EndoEq() {
	p.Endo(p)
}

// AddEq adds (via the elliptic curve group addition law) the given curve point x to the received p, overwriting p.
//
// p.AddEq(&x) is equivalent to p.AddEq(&p, &x)
func (p *Point_xtw_subgroup) AddEq(x CurvePointPtrInterfaceRead) {
	p.Add(p, x)
}

// AddEq adds (via the elliptic curve group addition law) the given curve point x to the received p, overwriting p.
//
// p.AddEq(&x) is equivalent to p.AddEq(&p, &x)
func (p *Point_xtw_full) AddEq(x CurvePointPtrInterfaceRead) {
	p.Add(p, x)
}

// SubEq subtracts (via the elliptic curve group addition law) the curve point x from the received p, overwriting p.
//
// p.SubEq(&x) is equivalent to p.SubEq(&p, &x)
func (p *Point_xtw_subgroup) SubEq(x CurvePointPtrInterfaceRead) {
	p.Sub(p, x)
}

// SubEq subtracts (via the elliptic curve group addition law) the curve point x from the received p, overwriting p.
//
// p.SubEq(&x) is equivalent to p.SubEq(&p, &x)
func (p *Point_xtw_full) SubEq(x CurvePointPtrInterfaceRead) {
	p.Sub(p, x)
}

// DoubleEq doubles the received point p, overwriting p.
//
// p.DoubleEq() is equivalent to p.Double(&p)
func (p *point_xtw_base) DoubleEq() {
	var result_efgh point_efgh_base
	result_efgh.double_st(p)
	*p = result_efgh.toDecaf_xtw()
}

// NegEq replaces the given point by its negative (wrt the elliptic curve group addition law).
//
// p.NegEq() is equivalent to p.NegEq(&p)
func (p *point_xtw_base) NegEq() {
	p.x.NegEq()
	p.t.NegEq()
}

// SetFromSubgroupPoint sets the receiver to a copy of the input, which needs to be in the prime-order subgroup.
// This method can be used to convert from point types capable of holding points not in the prime-order subgroup to point types that do not.
// The second argument needs to be either TrustedInput or UntrustedInput.
// For UntrustedInput, we actually check whether the input is in the subgroup; For TrustedInput, we assume it to be the case.
// The return value indicates success. On failure, the receiver is unchanged.
//
// NOTE: Calling this checks for NaPs even for TrustedInput.
// We make no guarantees whatsoever when calling it on points outside the subgroup with TrustedInput.
func (p *Point_xtw_subgroup) SetFromSubgroupPoint(input CurvePointPtrInterfaceRead, trusted IsPointTrusted) (ok bool) {
	if input.IsNaP() {
		napEncountered("Converting NaP to xtw via SetFromSubgroupPoint", false, input)
		*p = Point_xtw_subgroup{}
		return false
	}
	if input.CanOnlyRepresentSubgroup() {
		p.SetFrom(input)
		return true
	}
	if !trusted.Bool() {
		if !input.IsInSubgroup() {
			return false
		}
	}
	switch input := input.(type) {
	case *Point_xtw_full:
		p.point_xtw_base = input.point_xtw_base
	case *Point_axtw_full:
		p.x = input.x
		p.y = input.y
		p.t = input.t
		p.z.SetOne()
	case *Point_efgh_full:
		p.point_xtw_base = input.toDecaf_xtw()
	default:
		p.x = input.X_decaf_projective()
		p.y = input.Y_decaf_projective()
		p.t = input.T_decaf_projective()
		p.z = input.Z_decaf_projective()
	}
	return true
}

// SetFromSubgroupPoint sets the receiver to a copy of the input, which needs to be in the prime-order subgroup.
// This method can be used to convert from point types capable of holding points not in the prime-order subgroup to point types that do not.
// The second argument needs to be either TrustedInput or UntrustedInput.
// For UntrustedInput, we actually check whether the input is in the subgroup; For TrustedInput, we assume it to be the case.
// The return value indicates success. On failure, the receiver is unchanged.
//
// NOTE: Calling this checks for NaPs even for TrustedInput.
// We make no guarantees whatsoever when calling it on points outside the subgroup with TrustedInput.
func (p *Point_xtw_full) SetFromSubgroupPoint(input CurvePointPtrInterfaceRead, trusted IsPointTrusted) (ok bool) {
	if input.IsNaP() {
		napEncountered("Converting NaP point to xtw subgroup point", false, input)
		*p = Point_xtw_full{}
		return false
	}
	if !trusted.Bool() {
		if !input.IsInSubgroup() {
			return false
		}
	}
	p.SetFrom(input)
	return true
}

// SetFrom initializes the point from the given input point (which may have a different coordinate format).
//
// NOTE: To intialize a Point of type Point_xtw_subgroup with an input of a type that can hold points outside the subgroup, you need to use SetFromSubgroupPoint instead.
func (p *Point_xtw_subgroup) SetFrom(input CurvePointPtrInterfaceRead) {
	switch input := input.(type) {
	case *Point_xtw_subgroup:
		*p = *input
	case *Point_axtw_subgroup:
		p.x = input.x
		p.y = input.y
		p.t = input.t
		p.z.SetOne()
	case *Point_efgh_subgroup:
		p.point_xtw_base = input.toDecaf_xtw()
	default:
		ensureSubgroupOnly(input)
		p.x = input.X_decaf_projective()
		p.y = input.Y_decaf_projective()
		p.t = input.T_decaf_projective()
		p.z = input.Z_decaf_projective()
	}
}

// SetFrom initializes the point from the given input point (which may have a different coordinate format).
func (p *Point_xtw_full) SetFrom(input CurvePointPtrInterfaceRead) {
	switch input := input.(type) {
	case *Point_xtw_full:
		*p = *input
	case *Point_xtw_subgroup:
		input.normalizeSubgroup()
		p.point_xtw_base = input.point_xtw_base
	case *Point_axtw_full:
		p.x = input.x
		p.y = input.y
		p.t = input.t
		p.z.SetOne()
	case *Point_axtw_subgroup:
		input.normalizeSubgroup()
		p.x = input.x
		p.y = input.y
		p.t = input.t
		p.z.SetOne()
	case *Point_efgh_subgroup:
		input.normalizeSubgroup()
		p.point_xtw_base = input.toDecaf_xtw()
	case *Point_efgh_full:
		p.point_xtw_base = input.toDecaf_xtw()
	case CurvePointPtrInterfaceCooReadExtended:
		p.x, p.y, p.t, p.z = input.XYTZ_projective()
	default:
		p.x, p.y, p.z = input.XYZ_projective()
		p.t.Mul(&p.x, &p.y)
		p.x.MulEq(&p.z)
		p.y.MulEq(&p.z)
		p.z.SquareEq()
	}
}

// Validate checks whether the point is a valid curve point.
//
// NOTE: Outside of NaPs, it should not be possible to create points that fail Validate when using the interface correctly.
// Validate is used only in testing and is required by the CurvePointPtrInterfaceTestSample interface.
func (p *point_xtw_base) Validate() bool {
	return p.isPointOnCurve()
}

// Validate checks whether the point is a valid curve point.
//
// NOTE: Outside of NaPs, it should not be possible to create points that fail Validate when using the interface correctly.
// Validate is used only in testing and is required by the CurvePointPtrInterfaceTestSample interface.
func (p *Point_xtw_subgroup) Validate() bool {
	return p.point_xtw_base.isPointOnCurve() && legendreCheckA_projectiveXZ(p.x, p.z)
}

// sampleRandomUnsafe samples a (pseudo-)random curvepoint.
// It is used in testing only and required by the CurvePointPtrInterfaceTestValue interface.
//
// NOTE: While good enough for testing, the randomness quality is insufficient for cryptographic purposes.
// This is why we do not export this.
func (p *Point_xtw_full) sampleRandomUnsafe(rnd *rand.Rand) {
	p.point_xtw_base = makeRandomPointOnCurve_t(rnd)
}

// sampleRandomUnsafe samples a (pseudo-)random curvepoint.
// It is used in testing only and required by the CurvePointPtrInterfaceTestValue interface.
//
// NOTE: While good enough for testing, the randomness quality is insufficient for cryptographic purposes.
// This is why we do not export this.
func (p *Point_xtw_subgroup) sampleRandomUnsafe(rnd *rand.Rand) {
	p.point_xtw_base = makeRandomPointOnCurve_t(rnd)
	p.point_xtw_base.DoubleEq()
}

// SetE1 sets the point to the E1 point at infinity.
//
// This function is required in order to satisfy the curvePointPtrInterfaceTestSampleE interface, which
// our testing framework mandates that Point_xtw_full must satisfy.
func (p *Point_xtw_full) SetE1() {
	p.point_xtw_base = infinitePoint1_xtw_base
}

// SetE2 sets the point to the E2 point at infinity.
//
// This function is required in order to satisfy the curvePointPtrInterfaceTestSampleE interface, which
// our testing framework mandates that Point_xtw_full must satisfy.
func (p *Point_xtw_full) SetE2() {
	p.point_xtw_base = infinitePoint2_xtw_base
}

// SetAffineTwoTorsion sets the point to the affine-order two point.
//
// This function is required in order to satisfy the curvePointPtrInterfaceTestSampleA interface, which
// our testing framework mandates that Point_axtw_full must satisfy.
func (p *Point_xtw_full) SetAffineTwoTorsion() {
	p.point_xtw_base = orderTwoPoint_xtw
}
