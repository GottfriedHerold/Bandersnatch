package bandersnatch

import (
	"fmt"
	"math/big"
	"math/rand"
)

// Curve parameters

// Order of the p253-subgroup of the Bandersnatch curve. This is a 253-bit prime.
const (
	GroupOrder        = 0x1cfb69d4ca675f520cce760202687600ff8f87007419047174fd06b52876e7e1
	GroupOrder_string = "0x1cfb69d4ca675f520cce760202687600ff8f87007419047174fd06b52876e7e1"
)

const (
	Cofactor        = 4
	Cofactor_string = "4"
)
const (
	CurveOrder        = 52435875175126190479447740508185965837236623573762281007145613226918750691204 // = Cofactor * GroupOrder
	CurveOrder_string = "52435875175126190479447740508185965837236623573762281007145613226918750691204"
)

var GroupOrder_Int *big.Int = initIntFromString(GroupOrder_string)
var Cofactor_Int *big.Int = big.NewInt(Cofactor)
var CurveOrder_Int *big.Int = new(big.Int).Mul(GroupOrder_Int, Cofactor_Int)

// The efficient degree-2 endomorphism acts by multiplication by this constant on the p253-subgroup.
// Note that this is a square root of -2 modulo GroupOrder
const (
	EndomorphismEivenvalue        = 0x13b4f3dc4a39a493edf849562b38c72bcfc49db970a5056ed13d21408783df05
	EndomorphismEigenvalue_string = "0x13b4f3dc4a39a493edf849562b38c72bcfc49db970a5056ed13d21408783df05"
)

const endomorphismEigenvalueIsOdd = true // we chose an odd representative above. This info is needed to get some test right.

var EndomorphismEigenvalue_Int *big.Int = initIntFromString(EndomorphismEigenvalue_string)

// parameters a, d in twisted Edwards form ax^2 + y^2 = 1 + dx^2y^2

// Note: both a and d are non-squares

const (
	CurveParameterA        = -5
	CurveParameterA_string = "-5"
)

const (
	CurveParameterD        = 0x6389c12633c267cbc66e3bf86be3b6d8cb66677177e54f92b369f2f5188d58e7
	CurveParameterD_string = "0x6389c12633c267cbc66e3bf86be3b6d8cb66677177e54f92b369f2f5188d58e7"
)

// const, really
var (
	CurveParameterD_Int *big.Int     = initIntFromString(CurveParameterD_string)
	CurveParameterD_fe  FieldElement = initFieldElementFromString(CurveParameterD_string)
	CurveParameterA_Int *big.Int     = initIntFromString(CurveParameterA_string)
	CurveParameterA_fe  FieldElement = initFieldElementFromString(CurveParameterA_string)
)

// squareRootDByA is a square root of d/a. Due to the way the bandersnatch curve was constructed, we have (sqrt(d/a) + 1)^2 == 2.
// This number appears in coordinates of the order-2 points at inifinity and in the formulae for the endomorphism.
const (
	squareRootDByA        = 37446463827641770816307242315180085052603635617490163568005256780843403514038
	squareRootDByA_string = "37446463827641770816307242315180085052603635617490163568005256780843403514038"
)

// const, really
var (
	// squareRootDbyA_Int *big.Int     = initIntFromString(squareRootDByA_string) // TODO: Do we need this?
	squareRootDbyA_fe FieldElement = initFieldElementFromString(squareRootDByA_string)
)

// The point here is to force users to write Deserialize(..., TrustedInput, ...) rather than Deserialize(..., true, ...)
// in order to have better understandable semantics
// Golang does not have enum types, sadly, so we need to use structs: declaring a "type InPointTrusted bool" would cause Deserialze(..., true, ...)  to actually work due to implicit conversion.
type IsPointTrusted struct {
	v bool
}

func (b IsPointTrusted) V() bool { return b.v }

// const, really.
var (
	TrustedInput   IsPointTrusted = IsPointTrusted{v: true}
	UntrustedInput IsPointTrusted = IsPointTrusted{v: false}
)

/*
	Caveat: Bandersnatch is typically represented as a twisted Edwards curve, which means there are singularities
	at infinity. These singularities are not in the large-prime order subgroup. (the cofactor is 4)
	and only really correspond to curve points after desingularization anyway.

	To avoid these issues, we shall assert (and check on external input) that all points in the correct subgroup, which we
	represent as G' modulo P=P+A, where G' is the subgroup of rational point that is generated by the prime-order subgroup
	and the affine order-2 point A.
	Effectively, this means that we need to ensure that all points are in G' and that we work modulo A.

	The side effect of this is that avoid the singular cases for the addition law.

	Note that most non-comparison operations actually give the correct result even when not working modulo A.
	We explicitly document this if it is not the case (notably, when using the GLV endomorphism to speed up exponentiation)
	Unless explicitly specified otherwise, we do not guarantee correctness on our algorithms for points outside the subgroup G'.
*/

// A CurvePointPtrInterface represents a rational point on the bandersnatch curve in the correct subgroup.
// The interface is split into Read-only and write parts. This is mostly to clarify writing "general" functions.
// The (somewhat verbose) name is to emphasize this is an interface and that this contains *pointers*.
// Also, it allows to to alias CurvePoint to, say, Point_xtw without causing confusion.

// The _FullCurve interface extends this to operate also outside the p253-subgroup.
// Notably, the internel representation and operations are (mostly) meaningful for the full group of rational point -- the subgroup check is only performed when creating a point via the interface intended for the user.
// CurvePointPtrInterface_FullCurve contains some operations that act meaningfully on this internal representation without making the P=P+A identification.
// Note: The semantics of the _FullCurve - variants are not quite obvious. They are used mostly to make (stricter) tests that check that the implementation acts as designed.
// It's not clear whether this extended interface is useful outside of debugging and whether it should even be exported at all.

// Note: The actual implementations that are provided for Point_xtw, Point_axtw, Point_efgh
// give correct results even if types are mixed.

type Cloneable interface {
	Clone() interface{}
}

type Rerandomizeable interface {
	rerandomizeRepresentation(rnd *rand.Rand)
}

type Validateable interface {
	Validate() bool
}

// debug only
type sampleable interface {
	sampleRandomUnsafe(rnd *rand.Rand)
}

type torsionAdder interface {
	torsionAddA()
	torsionAddE1()
	torsionAddE2()
}

type CurvePointPtrInterfaceCooReadProjectiveXYZ interface {
	// These give coordinates of the point in projective coordinates.
	// Calls to other functions are allowed to modify the internal representation to change to an equivalent point (and thereby change coordinates)
	// Subsequent calls to <foo>_projective (with different foos) are guaranteed to be consistent only if there are no intermediate calls to other functions.
	X_projective() FieldElement
	Y_projective() FieldElement
	Z_projective() FieldElement
	XYZ_projective() (FieldElement, FieldElement, FieldElement)
}

type CurvePointPtrInterfaceCooReadAffineXY interface {
	// These give coordinates of the point in affine coordinates.
	// Calls to other functions are allowed to modify the internal representation to change to an equivalent point (and thereby change coordinates -- Note that the P=P+A identification allows this even for affine coordinates).
	// Subsequent calls to <foo>_affine (with different foos) are guaranteed to be consistent only if there are no intermediate calls to other functions.
	X_affine() FieldElement
	Y_affine() FieldElement
	XY_affine() (FieldElement, FieldElement)
}

type CurvePointPtrInterfaceCooReadProjectiveT interface {
	T_projective() FieldElement
	XYTZ_projective() (FieldElement, FieldElement, FieldElement, FieldElement)
}

type CurvePointPtrInterfaceCooReadAffineT interface {
	T_affine() FieldElement
	XYT_affine() (FieldElement, FieldElement, FieldElement)
}

type CurvePointPtrInterfaceCooReadExtended interface {
	CurvePointPtrInterfaceCooReadAffineT
	CurvePointPtrInterfaceCooReadProjectiveT
}

type CurvePointPtrInterfaceCooReadDecafProjective interface {
	X_decaf_projective() FieldElement
	Y_decaf_projective() FieldElement
	T_decaf_projective() FieldElement
	Z_decaf_projective() FieldElement
}

type CurvePointPtrInterfaceCooReadDecafAffine interface {
	X_decaf_affine() FieldElement
	Y_decaf_affine() FieldElement
	T_decaf_affine() FieldElement
}

type CurvePointPtrInterfaceTypeQuery interface {
	CanRepresentInfinity() bool
	CanOnlyRepresentSubgroup() bool
	HasDecaf() bool // if true, flipDecaf() must exist AND not change semantics.
}

type CurvePointPtrInterfaceDecaf interface {
	flipDecaf()
}

type CurvePointPtrInterfaceCompare interface {
	IsNeutralElement() bool
	IsNaP() bool
	IsEqual(CurvePointPtrInterfaceRead) bool
	IsInSubgroup() bool
	IsAtInfinity() bool
}

type CurvePointPtrInterfaceReadCanDistinguishInfinity interface {
	IsE1() bool
}

type CurvePointPtrInterfaceBaseRead interface {
	fmt.Stringer
	Cloneable
	CurvePointPtrInterfaceCooReadDecafAffine
	CurvePointPtrInterfaceCooReadDecafProjective
	CurvePointPtrInterfaceTypeQuery
}

/*
type CurvePointPtrInterfaceReadSerialize interface {
	// SerializeShort and SerializeLong serialize the given point in either short or long serialization format. err==nil iff everything worked OK.
	SerializeShort(output io.Writer) (bytes_written int, err error)
	SerializeLong(output io.Writer) (bytes_written int, err error)
}
*/

type CurvePointPtrInterfaceRead interface {
	CurvePointPtrInterfaceBaseRead
	CurvePointPtrInterfaceCompare
	CurvePointPtrInterfaceCooReadProjectiveXYZ
	CurvePointPtrInterfaceCooReadAffineXY
}

type CurvePointPtrInterfaceWriteArithmetic interface {
	SetNeutral()
	Add(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)
	Sub(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)
	Neg(CurvePointPtrInterfaceRead)
	Double(CurvePointPtrInterfaceRead)
	AddEq(CurvePointPtrInterfaceRead)
	SubEq(CurvePointPtrInterfaceRead)
	NegEq()
	DoubleEq()
}

type CurvePointPtrInterfaceWriteEndo interface {
	Endo(CurvePointPtrInterfaceRead)
	EndoEq()
}

type CurvePointPtrInterfaceWriteConvert interface {
	SetFrom(CurvePointPtrInterfaceRead)
}

type CurvePointPtrInterfaceWrite interface {
	CurvePointPtrInterfaceWriteArithmetic
	CurvePointPtrInterfaceWriteEndo
	CurvePointPtrInterfaceWriteConvert
}

type CurvePointPtrInterface interface {
	CurvePointPtrInterfaceRead
	CurvePointPtrInterfaceWrite
}

type thisCurvePointCanRepresentInfinity struct{}
type thisCurvePointCannotRepresentInfinity struct{}
type thisCurvePointCanOnlyRepresentSubgroup struct{}
type thisCurvePointCanRepresentFullCurve struct{}

func (thisCurvePointCanRepresentInfinity) CanRepresentInfinity() bool         { return true }
func (thisCurvePointCannotRepresentInfinity) CanRepresentInfinity() bool      { return false }
func (thisCurvePointCanOnlyRepresentSubgroup) CanOnlyRepresentSubgroup() bool { return true }
func (thisCurvePointCanOnlyRepresentSubgroup) IsInSubgroup() bool             { return true }
func (thisCurvePointCanRepresentFullCurve) CanOnlyRepresentSubgroup() bool    { return false }
func (thisCurvePointCanRepresentFullCurve) HasDecaf() bool                    { return false }

func ensureSubgroupOnly(input CurvePointPtrInterfaceTypeQuery) {
	if !input.CanOnlyRepresentSubgroup() {
		panic("curve_point: You are trying to assign (via an operation) to a point type that can only store subgroup points, but the operands are general. This is not allowed. Use explicit conversion instead.")
	}
}

/*
type CurvePointPtrInterfaceRead interface {
	CurvePointPtrInterfaceCooRead

	// Checks whether the given curve point is the neutral element of the curve.
	IsNeutralElement() bool

	// IsEqual checks equality of points. Note that the library acts as if the points were converted to the same concrete type.
	IsEqual(CurvePointPtrInterfaceRead) bool

	// IsNaP checks whether the point is a NaP (Not-A-Point).
	// NaP's can only appear due to bugs in the library or due to screw-ups on the user's side such as using uninitialized variables or deserializing erroneous points as trusted inputs.
	// We mostly use this internally at certain places to protect/alert users when certain errors occur.
	// Note that singular cases for group operations also lead to NaPs (But these cases can only appear (outside of testing or working on the full curve) due to bugs in the library or the user screwing up)
	IsNaP() bool

	// AffineExtended() and ExtendedTwistedEdwards() create a copy of the given point in the appropriate coordinate type.
	AffineExtended() Point_axtw
	ExtendedTwistedEdwards() Point_xtw

	// Creates a copy of the point of the same type and returns it (Note that the returned value must have interface type and that interface contains a pointer)
	Clone() CurvePointPtrInterfaceRead

	// SerializeShort and SerializeLong serialize the given point in either short or long serialization format. err==nil iff everything worked OK.
	SerializeShort(output io.Writer) (bytes_written int, err error)
	SerializeLong(output io.Writer) (bytes_written int, err error)

	fmt.Stringer // i.e. Stringer() string  -- used to obtain a human-readable version of the point, used mostly for debugging.

	// This function is intended to return a constant true or false, depending on whether the
	// concrete type implementing the interface can correctly represent (and distinguish) the 2 points at infinity. -- Of course, these are not in the subgroup.
	// This is used in testing and should work even on a nil receiver of the given concrete curve point type.
	// If this returns true, CurvePointPtrInterfaceRead_FullCurve must be provided.
	CanRepresentInfinity() bool
}
*/

/*
// CurvePointPtrInterfaceRead_FullCurve is the "extended interface" that contains functions that are needed to operate outside the p253 - subgroup and the identification P=P+A.
// Question: We might *not* export this interface at all.
type CurvePointPtrInterfaceRead_FullCurve interface {
	CurvePointPtrInterfaceRead
	IsNeutralElement_FullCurve() bool
	IsEqual_FullCurve(CurvePointPtrInterfaceRead_FullCurve) bool
	IsAtInfinity() bool
}
*/

/*
type CurvePointPtrInterfaceWrite interface {
	// z.Add(x,y) computes z = x+y according to the elliptic curve group law.
	Add(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)

	// z.Sub(x,y) computes z = x-y according to the elliptic curve group law.
	Sub(CurvePointPtrInterfaceRead, CurvePointPtrInterfaceRead)

	// z.Double(x) computes z = x+x according to the elliptic curve group law.
	Double(CurvePointPtrInterfaceRead)

	// z.Neg(x) computes z = -x according to the elliptic curve group law.
	Neg(CurvePointPtrInterfaceRead)

	// z.Endo(x) compute z = \Psi(x) where \Psi is the non-trivial degree-2 endomorphism described in the bandersnatch paper.
	Endo(CurvePointPtrInterfaceRead)

	// z.SetNeutral() sets z to be the neutral element of the curve.
	SetNeutral()

	// z.AddEq(x) is equivalent to z.Add(z,x), i.e. z+=x
	AddEq(CurvePointPtrInterfaceRead)

	// z.SubEq(x) is equivalent to z.Sub(z,x), i.e. z-=xx
	SubEq(CurvePointPtrInterfaceRead)

	// z.DoubleEq() is equivalent to z.Double(z), i.e. z*=2
	DoubleEq()

	// z.NegEq() is equivalent to z.Neg(z), i.e. z*=(-1)
	NegEq()

	// z.EndoEq() is equivalent to z.Endo(z)
	EndoEq()

	// z.SetFrom(x) sets z to x (with appropriate type conversion)
	SetFrom(CurvePointPtrInterfaceRead)

	// DeserialzeShort deserialize from the given input byte stream (expecting it to start with a point in short serialization format) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeShort(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)

	// DeserialzeLong deserialize from the given input byte stream (expecting it to start with a point in long serialization format) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeLong(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)

	// DeserialzeAuto deserialize from the given input byte stream (expecting it to start with a point in either short or long serialization format -- it autodetects that) and store the result in the receiver.
	// err==nil iff no error occured. trusted should be one of the constants TrustedInput or UntrustedInput.
	// For UntrustedInput, we perform a specially-tailored efficient curve and subgroup membership tests.
	// Note that long format is considerably more efficient to deserialize.
	DeserializeAuto(input io.Reader, trusted IsPointTrusted) (bytes_read int, err error)
}
*/

/*
type CurvePointPtrInterfaceWrite_FullCurve interface {
	CurvePointPtrInterfaceWrite
	Endo_FullCurve(CurvePointPtrInterfaceRead_FullCurve)
}
*/

/*
type CurvePointPtrInterface interface {
	CurvePointPtrInterfaceRead
	CurvePointPtrInterfaceWrite
}
*/

/*
type CurvePointPtrInterface_FullCurve interface {
	CurvePointPtrInterfaceRead_FullCurve
	CurvePointPtrInterfaceWrite_FullCurve
}
*/

// Note: We also have MapToFieldElement(CurvePointRead) FieldElement as a free-function that acts as an injective map p253 -> BaseField

// Note: Some of these are unused. Make consistent with Bandersnatch paper.

// These parameters appear in the formulae for the endomorphism.
const (
	// endo_a1              = 0x23c58c92306dbb95960f739827ac195334fcd8fa17df036c692f7ddaa306c7d4
	// endo_a1_string       = "0x23c58c92306dbb95960f739827ac195334fcd8fa17df036c692f7ddaa306c7d4"
	// endo_a2              = 0x23c58c92306dbb96b0b30d3513b222f50d02d8ff03e5036c69317ddaa306c7d4
	// endo_a2_string       = "0x23c58c92306dbb96b0b30d3513b222f50d02d8ff03e5036c69317ddaa306c7d4"
	endo_b               = 0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b4 // == sqrt(2) - 1 == sqrt(a/d)
	endo_b_string        = "0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b4"
	endo_binverse        = 0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b6 // =1/endo_b == endo_b + 2 == sqrt(d/a). Equals sqrtDByA
	endo_binverse_string = "0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b6"
	endo_bcd_string      = "36255886417209629651405037489028103282266637240540121152239675547668312569901" // == endo_b * endo_c * CurveParameterD
	endo_c               = 0x6cc624cf865457c3a97c6efd6c17d1078456abcfff36f4e9515c806cdf650b3d
	endo_c_string        = "0x6cc624cf865457c3a97c6efd6c17d1078456abcfff36f4e9515c806cdf650b3d"
	// endo_c1 == - endo_b
	//c1 = 0x2123b4c7a71956a2d149cacda650bd7d2516918bf263672811f0feb1e8daef4d
)

var (
	// endo_a1_fe       FieldElement = initFieldElementFromString(endo_a1_string)
	// endo_a2_fe       FieldElement = initFieldElementFromString(endo_a2_string)
	endo_b_fe        FieldElement = initFieldElementFromString(endo_b_string)
	endo_c_fe        FieldElement = initFieldElementFromString(endo_c_string)
	endo_binverse_fe FieldElement = initFieldElementFromString(endo_binverse_string) // Note == SqrtDDivA_fe
	endo_bcd_fe      FieldElement = initFieldElementFromString(endo_bcd_string)
)
